/* Main Thread entry function */
#include "main_thread.h"
#include "bsp_api.h"
#include "gx_api.h"
#include "r_i2c_api.h"
#include "gui/guiapp_specifications.h"
#include "gui/guiapp_resources.h"
#include "time.h"
#include "stdio.h"

#if defined(BSP_BOARD_S7G2_SK)
#include "hardware/lcd.h"
#endif

/***********************************************************************************************************************
    Private function prototypes
 ***********************************************************************************************************************/
static bool ssp_touch_to_guix(sf_touch_panel_payload_t * p_touch_payload, GX_EVENT * g_gx_event);
int checkAlarm();
void sync_time();
void addMs();
void main_thread_entry(void);
extern void initialise_monitor_handles(void);

#if defined(BSP_BOARD_S7G2_SK)
void g_lcd_spi_callback(spi_callback_args_t * p_args);
#endif

/***********************************************************************************************************************
    Private global variables
 ***********************************************************************************************************************/
static GX_EVENT g_gx_event;

//Timer1
bool            OnOff     = false;
UINT            statusI2C = SSP_SUCCESS;
int             DUMMY;
int             teller = 0;
bool            update = false;
bool            Flag = false;



int value  = 0;
int value1 = 0;
int value2 = 0;
int value3 = 0;

bool AL0 = true;
bool AL1 = true;
bool AL2 = true;
bool AL3 = true;
long unsigned int interuptTime;

#define Alarm1Pin IOPORT_PORT_04_PIN_02 //Pin 42
#define Alarm2Pin IOPORT_PORT_04_PIN_03 //Pin 43
#define Alarm3Pin IOPORT_PORT_04_PIN_04 //Pin 44
#define Alarm4Pin IOPORT_PORT_04_PIN_05 //Pin 45
#define FlagPin   IOPORT_PORT_04_PIN_06 //Pin 46

GX_WINDOW_ROOT * p_window_root;
extern GX_CONST GX_STUDIO_WIDGET *guiapp_widget_table[];

/*******************************************************************************************************************//**
    @brief  Primary logic for handling events generated by the various sub-systems.
 ***********************************************************************************************************************/
void main_thread_entry(void) {
    /* the interrupt configuration*/
    led_timer0.p_api->open(led_timer0.p_ctrl,led_timer0.p_cfg);
    Timer1.p_api->open(Timer1.p_ctrl,Timer1.p_cfg);
    //TimeAdd_timer0.p_api->open(TimeAdd_timer0.p_ctrl,TimeAdd_timer0.p_cfg);

    //all leds off
    g_ioport.p_api->pinWrite(IOPORT_PORT_06_PIN_00, true);   // GREEN LED
    g_ioport.p_api->pinWrite(IOPORT_PORT_06_PIN_01, true);   // Yellow LED
    g_ioport.p_api->pinWrite(IOPORT_PORT_06_PIN_02, true);   // Red LED

	ssp_err_t        err;
	sf_message_header_t * p_message = NULL;
	UINT      status    = TX_SUCCESS;

    //I2C stuff

    #define I2C_ADDRESS   0x68
    g_i2c0.p_api->open(g_i2c0.p_ctrl, g_i2c0.p_cfg);

    g_i2c0.p_api->reset(g_i2c0.p_ctrl);
    g_i2c0.p_api->slaveAddressSet(g_i2c0.p_ctrl, I2C_ADDRESS, I2C_ADDR_MODE_7BIT);

    sync_time();        //sync the time when the microcontroller starts.
    /* Initializes GUIX. */
    status = gx_system_initialize();


    /* start monitor */
    initialise_monitor_handles();
    printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
    printf("starting usb communication \n");
    //printf(timestamp() + "starting usb communication \n");


    if(TX_SUCCESS != status)
    {
        printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("failed to start TX \n");
        while(1);

    }

    /* Initializes GUIX drivers. */
    err = g_sf_el_gx.p_api->open (g_sf_el_gx.p_ctrl, g_sf_el_gx.p_cfg);
    if(SSP_SUCCESS != err)
    {
        printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("failed to start the driver \n");
        while(1);
    }

    gx_studio_display_configure ( DISPLAY_1,
                                  g_sf_el_gx.p_api->setup,
                                  LANGUAGE_ENGLISH,
                                  DISPLAY_1_THEME_1,
                                  &p_window_root );

    err = g_sf_el_gx.p_api->canvasInit(g_sf_el_gx.p_ctrl, p_window_root);
    if(SSP_SUCCESS != err)
    {
        printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("failed to start canvas \n");
        while(1);

    }

    // Create the widgets we have defined with the GUIX data structures and resources.
    GX_CONST GX_STUDIO_WIDGET ** pp_studio_widget = &guiapp_widget_table[0];
    GX_WIDGET * p_first_screen = NULL;

    while (GX_NULL != *pp_studio_widget)
    {
        // We must first create the widgets according the data generated in GUIX Studio.

        // Once we are working on the widget we want to see first, save the pointer for later.
        if (0 == strcmp("Main", (char*)(*pp_studio_widget)->widget_name))
        {
            gx_studio_named_widget_create((*pp_studio_widget)->widget_name, (GX_WIDGET *)p_window_root, GX_NULL);
        } else {
            gx_studio_named_widget_create((*pp_studio_widget)->widget_name, GX_NULL, GX_NULL);
        }
        // Move to next top-level widget
        pp_studio_widget++;
    }
    // Attach the first screen to the root so we can see it when the root is shown
   gx_widget_attach(p_window_root, p_first_screen);


    if(TX_SUCCESS != status)
    {
        printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("attach widget failed \n");
            while(1);
    }

    /* Shows the root window to make it and patients screen visible. */
    status = gx_widget_show(p_window_root);
    if(TX_SUCCESS != status)
    {
        printf("%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("failed to show widget \n");
        while(1);
    }

    /* Lets GUIX run. */
    status = gx_system_start();
    if(TX_SUCCESS != status)
    {
        printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("failed to start GUIX");
        while(1);
    }

#if defined(BSP_BOARD_S7G2_SK)
    /** Open the SPI driver to initialize the LCD (SK-S7G2) **/
    err = g_spi_lcdc.p_api->open(g_spi_lcdc.p_ctrl, (spi_cfg_t *)g_spi_lcdc.p_cfg);
    if (err)
    {
        printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("failed to start the lcd \n");
        while(1);
    }
    /** Setup the ILI9341V (SK-S7G2) **/
    ILI9341V_Init();
#endif

    /* Controls the GPIO pin for LCD ON (DK-S7G2, PE-HMI1) */
#if defined(BSP_BOARD_S7G2_DK)
    err = false;
    if (err)
    {
        printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("board define failed \n");
        while(1);
    }
#elif defined(BSP_BOARD_S7G2_PE_HMI1)
    err = false;
    if (err)
    {
        printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("board define failed");
        while(1);
    }
#endif

    /* Opens PWM driver and controls the TFT panel back light (DK-S7G2, PE-HMI1) */
#if defined(BSP_BOARD_S7G2_DK) || defined(BSP_BOARD_S7G2_PE_HMI1)
    err = g_pwm_backlight.p_api->open(g_pwm_backlight.p_ctrl, g_pwm_backlight.p_cfg);
    if (err)
    {
        printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
        printf("backlight failed");
        while(1);
    }
#endif

	while(1)
	{
		bool new_gui_event = false;

		err = g_sf_message0.p_api->pend(g_sf_message0.p_ctrl, &main_thread_message_queue, (sf_message_header_t **) &p_message, TX_WAIT_FOREVER);
		if (err)
		{
		    printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
		    printf("invalid message \n");
		}

		switch (p_message->event_b.class_code)
		{
		case SF_MESSAGE_EVENT_CLASS_TOUCH:
		{
			switch (p_message->event_b.code)
			{
			case SF_MESSAGE_EVENT_NEW_DATA:
			{
				/** Translate an SSP touch event into a GUIX event */
				new_gui_event = ssp_touch_to_guix((sf_touch_panel_payload_t*)p_message, &g_gx_event);
			}
			default:
				break;
			}
			break;
		}
		default:
			break;
		}

		/** Message is processed, so release buffer. */
		err = g_sf_message0.p_api->bufferRelease(g_sf_message0.p_ctrl, (sf_message_header_t *) p_message, SF_MESSAGE_RELEASE_OPTION_FORCED_RELEASE);
		
		if (err)
		{
            printf( "%i/%i/%i - %i:%i:%i :", getYear(), getMonth(), getDate(), getHour(), getMin(), getSec());
            printf("invalid message \n");
		}

		/** Post message. */
		if (new_gui_event) {
			gx_system_event_send(&g_gx_event);
		}
	}
}

static bool ssp_touch_to_guix(sf_touch_panel_payload_t * p_touch_payload, GX_EVENT * gx_event)
{
	bool send_event = true;
	switch (p_touch_payload->event_type)
	{
	case SF_TOUCH_PANEL_EVENT_DOWN:
		gx_event->gx_event_type = GX_EVENT_PEN_DOWN;
		break;
	case SF_TOUCH_PANEL_EVENT_UP:
		gx_event->gx_event_type = GX_EVENT_PEN_UP;
		break;
	case SF_TOUCH_PANEL_EVENT_HOLD:
	case SF_TOUCH_PANEL_EVENT_MOVE:
		gx_event->gx_event_type = GX_EVENT_PEN_DRAG;
		break;
	case SF_TOUCH_PANEL_EVENT_INVALID:
		send_event = false;
		break;
	default:
		break;
	}

	if (send_event)
	{
		/** Send event to GUI */
		gx_event->gx_event_sender = GX_ID_NONE;
		gx_event->gx_event_target = 0;
		gx_event->gx_event_display_handle = 0;

		gx_event->gx_event_payload.gx_event_pointdata.gx_point_x = p_touch_payload->x;

#if defined(BSP_BOARD_S7G2_SK)
		gx_event->gx_event_payload.gx_event_pointdata.gx_point_y = (GX_VALUE)(320 - p_touch_payload->y);  // SK-S7G2
#else
		gx_event->gx_event_payload.gx_event_pointdata.gx_point_y = p_touch_payload->y;  // DK-S7G2, PE-HMI1
#endif
	}

	return send_event;
}

#if defined(BSP_BOARD_S7G2_SK)
void g_lcd_spi_callback(spi_callback_args_t * p_args)
{
    (void)p_args;
    tx_semaphore_ceiling_put(&g_main_semaphore_lcdc, 1);
}
#endif

void led_timer0_callback(timer_callback_args_t * p_args){
    //start the flag and output it on pin
    Flag = !Flag;
    g_ioport.p_api->pinWrite(FlagPin, Flag);

    addMs();
    //Alarm 1
    value  = checkAlarm1();
    if (value == 1){
        AL0 = false;
    }
    else if (value == 0){
        AL0 = true;
    }
    AL0 = !AL0;
    g_ioport.p_api->pinWrite(Alarm1Pin, AL0);
    //Alarm 2
    value1 = checkAlarm2();
    if (value1 == 1){
        AL1 = false;
    }
    else if (value1 == 0){
        AL1 = true;
    }
    AL1 = !AL1;
    g_ioport.p_api->pinWrite(Alarm2Pin, AL1);
    //Alarm 3
    value2 = checkAlarm3();
    if (value2 == 1){
        AL2 = false;
    }
    else if (value2 == 0){
        AL2 = true;
    }
    AL2 = !AL2;
    g_ioport.p_api->pinWrite(Alarm3Pin, AL2);
    //Alarm 4
    value3 = checkAlarm4();
    if (value3 == 1){
        AL3 = false;
    }
    else if (value3 == 0){
        AL3 = true;
    }
    AL3 = !AL3;
    g_ioport.p_api->pinWrite(Alarm4Pin, AL3);

    Flag = !Flag;
    g_ioport.p_api->pinWrite(FlagPin, Flag);
}

//Timer that runs every second
void Timer1_callback(timer_callback_args_t * p_args){
//every second check if the RTC is online.
//if its not then blink red if it is then blink green

    //every time the timer is called excecute one EEPROM read to not overload the EEPROM
    if(update == false){
        switch (teller)
            {
            case 1:
                readauto();
                break;
            case 2:
                alarmpwm1read();
                break;
            case 3:
                alarmpwm2read();
                break;
            case 4:
                alarmpwm3read();
                break;
            case 5:
                alarmpwm4read();
                break;
            default:
                break;
            }
        teller = teller + 1;
        if(teller == 6){
            teller = 0;
            update = true;
        }
    }

    g_i2c0.p_api->reset(g_i2c0.p_ctrl);
    g_i2c0.p_api->slaveAddressSet(g_i2c0.p_ctrl, I2C_ADDRESS, I2C_ADDR_MODE_7BIT);

    statusI2C = g_i2c0.p_api->read(g_i2c0.p_ctrl, &DUMMY, 1, false);

    if(SSP_SUCCESS == statusI2C){
        g_ioport.p_api->pinWrite(IOPORT_PORT_06_PIN_01, true);   // Red LED
        g_ioport.p_api->pinWrite(IOPORT_PORT_06_PIN_00, false);   // GREEN LED
    }
    else if(SSP_SUCCESS != statusI2C){
        g_ioport.p_api->pinWrite(IOPORT_PORT_06_PIN_01, OnOff);   // Red LED
        g_ioport.p_api->pinWrite(IOPORT_PORT_06_PIN_00, true);   // GREEN LED
        OnOff = !OnOff;
        printf("Connect the RTC! \n");
    }
    //call on the EEPROM write function
    //only if something has changed and 5 seconds have passed to make sure to not strain the rtc4
}


